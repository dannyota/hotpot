//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
)

type schemaInfo struct {
	TypeName   string // e.g. "BronzeGCPComputeInstance"
	ImportPath string // e.g. "hotpot/pkg/schema/bronze/gcp/compute"
	Alias      string // e.g. "bronze_gcp_compute"
}

func main() {
	schemaRoot := filepath.Join("..", "schema")
	allSchemas := discoverSchemas(schemaRoot)

	// 1. Generate runtime wrappers (all layers combined)
	runtimeSchemaDir := filepath.Join("ent", "schema")
	os.MkdirAll(runtimeSchemaDir, 0755)

	if err := generateWrappers(runtimeSchemaDir, allSchemas); err != nil {
		log.Fatalf("generate runtime wrappers: %v", err)
	}

	// 2. Generate per-layer wrappers for Atlas (no prefix, one layer each)
	for layer, schemas := range allSchemas {
		atlasSchemaDir := filepath.Join("ent", layer, "atlas_schema")
		os.MkdirAll(atlasSchemaDir, 0755)

		layerSchemas := map[string][]schemaInfo{layer: schemas}
		if err := generateWrappers(atlasSchemaDir, layerSchemas); err != nil {
			log.Fatalf("generate atlas wrappers for %s: %v", layer, err)
		}
	}

	// 3. Generate schema config helper (maps types to PG schemas)
	if err := generateSchemaConfig(allSchemas); err != nil {
		log.Fatalf("generate schema config: %v", err)
	}

	// 4. Run entc ONCE — generates ONE client with all types
	absRuntimeSchemaDir, err := filepath.Abs(runtimeSchemaDir)
	if err != nil {
		log.Fatalf("get abs path: %v", err)
	}

	if err := entc.Generate(absRuntimeSchemaDir, &gen.Config{
		Package:  "hotpot/pkg/storage/ent",
		Target:   "ent",
		Features: []gen.Feature{gen.FeatureSchemaConfig},
	}); err != nil {
		log.Fatalf("entc generate: %v", err)
	}
}

// layerToSchema maps directory names to PG schema names
var layerToSchema = map[string]string{
	"bronze":        "bronze",
	"bronzehistory": "bronze_history",
	"silver":        "silver",
	"gold":          "gold",
}

func generateSchemaConfig(schemasByLayer map[string][]schemaInfo) error {
	var entries strings.Builder
	for layer, schemas := range schemasByLayer {
		pgSchema := layerToSchema[layer]
		for _, s := range schemas {
			fmt.Fprintf(&entries, "\t\t%s: %q,\n", s.TypeName, pgSchema)
		}
	}

	src := fmt.Sprintf(`// Code generated by entc.go. DO NOT EDIT.
package ent

// DefaultSchemaConfig returns the schema config mapping each type to its PG schema.
func DefaultSchemaConfig() SchemaConfig {
	return SchemaConfig{
%s	}
}
`, entries.String())

	formatted, err := format.Source([]byte(src))
	if err != nil {
		return fmt.Errorf("format: %w (source: %s)", err, src)
	}
	return os.WriteFile(filepath.Join("ent", "schema_config_gen.go"), formatted, 0644)
}

func discoverSchemas(root string) map[string][]schemaInfo {
	layers := map[string][]schemaInfo{}

	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}
		if strings.Contains(path, "/mixin/") {
			return nil
		}

		fset := token.NewFileSet()
		f, parseErr := parser.ParseFile(fset, path, nil, 0)
		if parseErr != nil {
			return nil
		}

		dir := filepath.Dir(path)
		relDir, _ := filepath.Rel(root, dir)
		parts := strings.Split(relDir, string(os.PathSeparator))
		layer := parts[0]

		for _, decl := range f.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || !typeSpec.Name.IsExported() {
					continue
				}
				if embedsEntSchema(typeSpec) {
					alias := strings.ReplaceAll(relDir, string(os.PathSeparator), "_")
					layers[layer] = append(layers[layer], schemaInfo{
						TypeName:   typeSpec.Name.Name,
						ImportPath: "hotpot/pkg/schema/" + strings.ReplaceAll(relDir, string(os.PathSeparator), "/"),
						Alias:      alias,
					})
				}
			}
		}
		return nil
	})

	return layers
}

func embedsEntSchema(ts *ast.TypeSpec) bool {
	st, ok := ts.Type.(*ast.StructType)
	if !ok {
		return false
	}
	for _, f := range st.Fields.List {
		if len(f.Names) == 0 { // embedded field
			if sel, ok := f.Type.(*ast.SelectorExpr); ok {
				if ident, ok := sel.X.(*ast.Ident); ok {
					if ident.Name == "ent" && sel.Sel.Name == "Schema" {
						return true
					}
				}
			}
		}
	}
	return false
}

func generateWrappers(dir string, schemasByLayer map[string][]schemaInfo) error {
	var imports, types strings.Builder

	seen := map[string]bool{}
	for _, schemas := range schemasByLayer {
		for _, s := range schemas {
			if !seen[s.ImportPath] {
				fmt.Fprintf(&imports, "\t%s %q\n", s.Alias, s.ImportPath)
				seen[s.ImportPath] = true
			}
		}
	}

	// Names are already prefixed in source (BronzeGCPComputeInstance, etc.)
	// Just generate simple wrapper structs — no renaming needed
	for _, schemas := range schemasByLayer {
		for _, s := range schemas {
			fmt.Fprintf(&types, "type %s struct {\n\t%s.%s\n}\n\n", s.TypeName, s.Alias, s.TypeName)
		}
	}

	src := fmt.Sprintf("// Code generated by entc.go. DO NOT EDIT.\npackage schema\n\nimport (\n%s)\n\n%s", imports.String(), types.String())

	formatted, err := format.Source([]byte(src))
	if err != nil {
		return fmt.Errorf("format: %w (source: %s)", err, src)
	}
	return os.WriteFile(filepath.Join(dir, "schemas_gen.go"), formatted, 0644)
}
